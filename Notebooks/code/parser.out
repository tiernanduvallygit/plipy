Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> ID = exp opt_semi
Rule 5     stmt -> GET ID opt_semi
Rule 6     stmt -> PUT exp opt_semi
Rule 7     stmt -> WHILE ( exp ) stmt
Rule 8     stmt -> IF ( exp ) stmt opt_else
Rule 9     stmt -> { stmt_list }
Rule 10    opt_else -> ELSE stmt
Rule 11    opt_else -> empty
Rule 12    exp -> exp PLUS exp
Rule 13    exp -> exp MINUS exp
Rule 14    exp -> exp TIMES exp
Rule 15    exp -> exp DIVIDE exp
Rule 16    exp -> exp EQ exp
Rule 17    exp -> exp LE exp
Rule 18    exp -> INTEGER
Rule 19    exp -> ID
Rule 20    exp -> ( exp )
Rule 21    exp -> MINUS exp
Rule 22    exp -> NOT exp
Rule 23    opt_semi -> ;
Rule 24    opt_semi -> empty
Rule 25    empty -> <empty>

Terminals, with rules where they appear

(                    : 7 8 20
)                    : 7 8 20
;                    : 23
=                    : 4
DIVIDE               : 15
ELSE                 : 10
EQ                   : 16
GET                  : 5
ID                   : 4 5 19
IF                   : 8
INTEGER              : 18
LE                   : 17
MINUS                : 13 21
NOT                  : 22
PLUS                 : 12
PUT                  : 6
TIMES                : 14
WHILE                : 7
error                : 
{                    : 9
}                    : 9

Nonterminals, with rules where they appear

empty                : 3 11 24
exp                  : 4 6 7 8 12 12 13 13 14 14 15 15 16 16 17 17 20 21 22
opt_else             : 8
opt_semi             : 4 5 6
program              : 0
stmt                 : 2 7 8 10
stmt_list            : 1 2 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }
    (25) empty -> .

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10
    $end            reduce using rule 25 (empty -> .)

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }
    (25) empty -> .

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10
    $end            reduce using rule 25 (empty -> .)
    }               reduce using rule 25 (empty -> .)

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 11
    empty                          shift and go to state 4

state 4

    (3) stmt_list -> empty .

    $end            reduce using rule 3 (stmt_list -> empty .)
    }               reduce using rule 3 (stmt_list -> empty .)


state 5

    (4) stmt -> ID . = exp opt_semi

    =               shift and go to state 12


state 6

    (5) stmt -> GET . ID opt_semi

    ID              shift and go to state 13


state 7

    (6) stmt -> PUT . exp opt_semi
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 14

state 8

    (7) stmt -> WHILE . ( exp ) stmt

    (               shift and go to state 20


state 9

    (8) stmt -> IF . ( exp ) stmt opt_else

    (               shift and go to state 21


state 10

    (9) stmt -> { . stmt_list }
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }
    (25) empty -> .

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10
    }               reduce using rule 25 (empty -> .)

    stmt_list                      shift and go to state 22
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 11

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    }               reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 12

    (4) stmt -> ID = . exp opt_semi
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 23

state 13

    (5) stmt -> GET ID . opt_semi
    (23) opt_semi -> . ;
    (24) opt_semi -> . empty
    (25) empty -> .

    ;               shift and go to state 25
    ID              reduce using rule 25 (empty -> .)
    GET             reduce using rule 25 (empty -> .)
    PUT             reduce using rule 25 (empty -> .)
    WHILE           reduce using rule 25 (empty -> .)
    IF              reduce using rule 25 (empty -> .)
    {               reduce using rule 25 (empty -> .)
    $end            reduce using rule 25 (empty -> .)
    }               reduce using rule 25 (empty -> .)
    ELSE            reduce using rule 25 (empty -> .)

    opt_semi                       shift and go to state 24
    empty                          shift and go to state 26

state 14

    (6) stmt -> PUT exp . opt_semi
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp
    (23) opt_semi -> . ;
    (24) opt_semi -> . empty
    (25) empty -> .

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31
    EQ              shift and go to state 32
    LE              shift and go to state 33
    ;               shift and go to state 25
    ID              reduce using rule 25 (empty -> .)
    GET             reduce using rule 25 (empty -> .)
    PUT             reduce using rule 25 (empty -> .)
    WHILE           reduce using rule 25 (empty -> .)
    IF              reduce using rule 25 (empty -> .)
    {               reduce using rule 25 (empty -> .)
    $end            reduce using rule 25 (empty -> .)
    }               reduce using rule 25 (empty -> .)
    ELSE            reduce using rule 25 (empty -> .)

    opt_semi                       shift and go to state 27
    empty                          shift and go to state 26

state 15

    (21) exp -> MINUS . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 34

state 16

    (18) exp -> INTEGER .

    PLUS            reduce using rule 18 (exp -> INTEGER .)
    MINUS           reduce using rule 18 (exp -> INTEGER .)
    TIMES           reduce using rule 18 (exp -> INTEGER .)
    DIVIDE          reduce using rule 18 (exp -> INTEGER .)
    EQ              reduce using rule 18 (exp -> INTEGER .)
    LE              reduce using rule 18 (exp -> INTEGER .)
    ;               reduce using rule 18 (exp -> INTEGER .)
    ID              reduce using rule 18 (exp -> INTEGER .)
    GET             reduce using rule 18 (exp -> INTEGER .)
    PUT             reduce using rule 18 (exp -> INTEGER .)
    WHILE           reduce using rule 18 (exp -> INTEGER .)
    IF              reduce using rule 18 (exp -> INTEGER .)
    {               reduce using rule 18 (exp -> INTEGER .)
    $end            reduce using rule 18 (exp -> INTEGER .)
    }               reduce using rule 18 (exp -> INTEGER .)
    ELSE            reduce using rule 18 (exp -> INTEGER .)
    )               reduce using rule 18 (exp -> INTEGER .)


state 17

    (19) exp -> ID .

    PLUS            reduce using rule 19 (exp -> ID .)
    MINUS           reduce using rule 19 (exp -> ID .)
    TIMES           reduce using rule 19 (exp -> ID .)
    DIVIDE          reduce using rule 19 (exp -> ID .)
    EQ              reduce using rule 19 (exp -> ID .)
    LE              reduce using rule 19 (exp -> ID .)
    ;               reduce using rule 19 (exp -> ID .)
    ID              reduce using rule 19 (exp -> ID .)
    GET             reduce using rule 19 (exp -> ID .)
    PUT             reduce using rule 19 (exp -> ID .)
    WHILE           reduce using rule 19 (exp -> ID .)
    IF              reduce using rule 19 (exp -> ID .)
    {               reduce using rule 19 (exp -> ID .)
    $end            reduce using rule 19 (exp -> ID .)
    }               reduce using rule 19 (exp -> ID .)
    ELSE            reduce using rule 19 (exp -> ID .)
    )               reduce using rule 19 (exp -> ID .)


state 18

    (20) exp -> ( . exp )
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 35

state 19

    (22) exp -> NOT . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 36

state 20

    (7) stmt -> WHILE ( . exp ) stmt
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 37

state 21

    (8) stmt -> IF ( . exp ) stmt opt_else
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 38

state 22

    (9) stmt -> { stmt_list . }

    }               shift and go to state 39


state 23

    (4) stmt -> ID = exp . opt_semi
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp
    (23) opt_semi -> . ;
    (24) opt_semi -> . empty
    (25) empty -> .

    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31
    EQ              shift and go to state 32
    LE              shift and go to state 33
    ;               shift and go to state 25
    ID              reduce using rule 25 (empty -> .)
    GET             reduce using rule 25 (empty -> .)
    PUT             reduce using rule 25 (empty -> .)
    WHILE           reduce using rule 25 (empty -> .)
    IF              reduce using rule 25 (empty -> .)
    {               reduce using rule 25 (empty -> .)
    $end            reduce using rule 25 (empty -> .)
    }               reduce using rule 25 (empty -> .)
    ELSE            reduce using rule 25 (empty -> .)

    opt_semi                       shift and go to state 40
    empty                          shift and go to state 26

state 24

    (5) stmt -> GET ID opt_semi .

    ID              reduce using rule 5 (stmt -> GET ID opt_semi .)
    GET             reduce using rule 5 (stmt -> GET ID opt_semi .)
    PUT             reduce using rule 5 (stmt -> GET ID opt_semi .)
    WHILE           reduce using rule 5 (stmt -> GET ID opt_semi .)
    IF              reduce using rule 5 (stmt -> GET ID opt_semi .)
    {               reduce using rule 5 (stmt -> GET ID opt_semi .)
    $end            reduce using rule 5 (stmt -> GET ID opt_semi .)
    }               reduce using rule 5 (stmt -> GET ID opt_semi .)
    ELSE            reduce using rule 5 (stmt -> GET ID opt_semi .)


state 25

    (23) opt_semi -> ; .

    ID              reduce using rule 23 (opt_semi -> ; .)
    GET             reduce using rule 23 (opt_semi -> ; .)
    PUT             reduce using rule 23 (opt_semi -> ; .)
    WHILE           reduce using rule 23 (opt_semi -> ; .)
    IF              reduce using rule 23 (opt_semi -> ; .)
    {               reduce using rule 23 (opt_semi -> ; .)
    $end            reduce using rule 23 (opt_semi -> ; .)
    }               reduce using rule 23 (opt_semi -> ; .)
    ELSE            reduce using rule 23 (opt_semi -> ; .)


state 26

    (24) opt_semi -> empty .

    ID              reduce using rule 24 (opt_semi -> empty .)
    GET             reduce using rule 24 (opt_semi -> empty .)
    PUT             reduce using rule 24 (opt_semi -> empty .)
    WHILE           reduce using rule 24 (opt_semi -> empty .)
    IF              reduce using rule 24 (opt_semi -> empty .)
    {               reduce using rule 24 (opt_semi -> empty .)
    $end            reduce using rule 24 (opt_semi -> empty .)
    }               reduce using rule 24 (opt_semi -> empty .)
    ELSE            reduce using rule 24 (opt_semi -> empty .)


state 27

    (6) stmt -> PUT exp opt_semi .

    ID              reduce using rule 6 (stmt -> PUT exp opt_semi .)
    GET             reduce using rule 6 (stmt -> PUT exp opt_semi .)
    PUT             reduce using rule 6 (stmt -> PUT exp opt_semi .)
    WHILE           reduce using rule 6 (stmt -> PUT exp opt_semi .)
    IF              reduce using rule 6 (stmt -> PUT exp opt_semi .)
    {               reduce using rule 6 (stmt -> PUT exp opt_semi .)
    $end            reduce using rule 6 (stmt -> PUT exp opt_semi .)
    }               reduce using rule 6 (stmt -> PUT exp opt_semi .)
    ELSE            reduce using rule 6 (stmt -> PUT exp opt_semi .)


state 28

    (12) exp -> exp PLUS . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 41

state 29

    (13) exp -> exp MINUS . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 42

state 30

    (14) exp -> exp TIMES . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 43

state 31

    (15) exp -> exp DIVIDE . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 44

state 32

    (16) exp -> exp EQ . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 45

state 33

    (17) exp -> exp LE . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp
    (22) exp -> . NOT exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15
    NOT             shift and go to state 19

    exp                            shift and go to state 46

state 34

    (21) exp -> MINUS exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 21 (exp -> MINUS exp .)
    MINUS           reduce using rule 21 (exp -> MINUS exp .)
    TIMES           reduce using rule 21 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 21 (exp -> MINUS exp .)
    EQ              reduce using rule 21 (exp -> MINUS exp .)
    LE              reduce using rule 21 (exp -> MINUS exp .)
    ;               reduce using rule 21 (exp -> MINUS exp .)
    ID              reduce using rule 21 (exp -> MINUS exp .)
    GET             reduce using rule 21 (exp -> MINUS exp .)
    PUT             reduce using rule 21 (exp -> MINUS exp .)
    WHILE           reduce using rule 21 (exp -> MINUS exp .)
    IF              reduce using rule 21 (exp -> MINUS exp .)
    {               reduce using rule 21 (exp -> MINUS exp .)
    $end            reduce using rule 21 (exp -> MINUS exp .)
    }               reduce using rule 21 (exp -> MINUS exp .)
    ELSE            reduce using rule 21 (exp -> MINUS exp .)
    )               reduce using rule 21 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! TIMES           [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 35

    (20) exp -> ( exp . )
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    )               shift and go to state 47
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31
    EQ              shift and go to state 32
    LE              shift and go to state 33


state 36

    (22) exp -> NOT exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 22 (exp -> NOT exp .)
    MINUS           reduce using rule 22 (exp -> NOT exp .)
    TIMES           reduce using rule 22 (exp -> NOT exp .)
    DIVIDE          reduce using rule 22 (exp -> NOT exp .)
    EQ              reduce using rule 22 (exp -> NOT exp .)
    LE              reduce using rule 22 (exp -> NOT exp .)
    ;               reduce using rule 22 (exp -> NOT exp .)
    ID              reduce using rule 22 (exp -> NOT exp .)
    GET             reduce using rule 22 (exp -> NOT exp .)
    PUT             reduce using rule 22 (exp -> NOT exp .)
    WHILE           reduce using rule 22 (exp -> NOT exp .)
    IF              reduce using rule 22 (exp -> NOT exp .)
    {               reduce using rule 22 (exp -> NOT exp .)
    $end            reduce using rule 22 (exp -> NOT exp .)
    }               reduce using rule 22 (exp -> NOT exp .)
    ELSE            reduce using rule 22 (exp -> NOT exp .)
    )               reduce using rule 22 (exp -> NOT exp .)

  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! TIMES           [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 37

    (7) stmt -> WHILE ( exp . ) stmt
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    )               shift and go to state 48
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31
    EQ              shift and go to state 32
    LE              shift and go to state 33


state 38

    (8) stmt -> IF ( exp . ) stmt opt_else
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    )               shift and go to state 49
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31
    EQ              shift and go to state 32
    LE              shift and go to state 33


state 39

    (9) stmt -> { stmt_list } .

    ID              reduce using rule 9 (stmt -> { stmt_list } .)
    GET             reduce using rule 9 (stmt -> { stmt_list } .)
    PUT             reduce using rule 9 (stmt -> { stmt_list } .)
    WHILE           reduce using rule 9 (stmt -> { stmt_list } .)
    IF              reduce using rule 9 (stmt -> { stmt_list } .)
    {               reduce using rule 9 (stmt -> { stmt_list } .)
    $end            reduce using rule 9 (stmt -> { stmt_list } .)
    }               reduce using rule 9 (stmt -> { stmt_list } .)
    ELSE            reduce using rule 9 (stmt -> { stmt_list } .)


state 40

    (4) stmt -> ID = exp opt_semi .

    ID              reduce using rule 4 (stmt -> ID = exp opt_semi .)
    GET             reduce using rule 4 (stmt -> ID = exp opt_semi .)
    PUT             reduce using rule 4 (stmt -> ID = exp opt_semi .)
    WHILE           reduce using rule 4 (stmt -> ID = exp opt_semi .)
    IF              reduce using rule 4 (stmt -> ID = exp opt_semi .)
    {               reduce using rule 4 (stmt -> ID = exp opt_semi .)
    $end            reduce using rule 4 (stmt -> ID = exp opt_semi .)
    }               reduce using rule 4 (stmt -> ID = exp opt_semi .)
    ELSE            reduce using rule 4 (stmt -> ID = exp opt_semi .)


state 41

    (12) exp -> exp PLUS exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 12 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 12 (exp -> exp PLUS exp .)
    EQ              reduce using rule 12 (exp -> exp PLUS exp .)
    LE              reduce using rule 12 (exp -> exp PLUS exp .)
    ;               reduce using rule 12 (exp -> exp PLUS exp .)
    ID              reduce using rule 12 (exp -> exp PLUS exp .)
    GET             reduce using rule 12 (exp -> exp PLUS exp .)
    PUT             reduce using rule 12 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 12 (exp -> exp PLUS exp .)
    IF              reduce using rule 12 (exp -> exp PLUS exp .)
    {               reduce using rule 12 (exp -> exp PLUS exp .)
    $end            reduce using rule 12 (exp -> exp PLUS exp .)
    }               reduce using rule 12 (exp -> exp PLUS exp .)
    ELSE            reduce using rule 12 (exp -> exp PLUS exp .)
    )               reduce using rule 12 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31

  ! TIMES           [ reduce using rule 12 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 12 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 42

    (13) exp -> exp MINUS exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 13 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 13 (exp -> exp MINUS exp .)
    EQ              reduce using rule 13 (exp -> exp MINUS exp .)
    LE              reduce using rule 13 (exp -> exp MINUS exp .)
    ;               reduce using rule 13 (exp -> exp MINUS exp .)
    ID              reduce using rule 13 (exp -> exp MINUS exp .)
    GET             reduce using rule 13 (exp -> exp MINUS exp .)
    PUT             reduce using rule 13 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 13 (exp -> exp MINUS exp .)
    IF              reduce using rule 13 (exp -> exp MINUS exp .)
    {               reduce using rule 13 (exp -> exp MINUS exp .)
    $end            reduce using rule 13 (exp -> exp MINUS exp .)
    }               reduce using rule 13 (exp -> exp MINUS exp .)
    ELSE            reduce using rule 13 (exp -> exp MINUS exp .)
    )               reduce using rule 13 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31

  ! TIMES           [ reduce using rule 13 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 13 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 43

    (14) exp -> exp TIMES exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 14 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 14 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 14 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 14 (exp -> exp TIMES exp .)
    EQ              reduce using rule 14 (exp -> exp TIMES exp .)
    LE              reduce using rule 14 (exp -> exp TIMES exp .)
    ;               reduce using rule 14 (exp -> exp TIMES exp .)
    ID              reduce using rule 14 (exp -> exp TIMES exp .)
    GET             reduce using rule 14 (exp -> exp TIMES exp .)
    PUT             reduce using rule 14 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 14 (exp -> exp TIMES exp .)
    IF              reduce using rule 14 (exp -> exp TIMES exp .)
    {               reduce using rule 14 (exp -> exp TIMES exp .)
    $end            reduce using rule 14 (exp -> exp TIMES exp .)
    }               reduce using rule 14 (exp -> exp TIMES exp .)
    ELSE            reduce using rule 14 (exp -> exp TIMES exp .)
    )               reduce using rule 14 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! TIMES           [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 44

    (15) exp -> exp DIVIDE exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 15 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 15 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 15 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 15 (exp -> exp DIVIDE exp .)
    EQ              reduce using rule 15 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 15 (exp -> exp DIVIDE exp .)
    ;               reduce using rule 15 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 15 (exp -> exp DIVIDE exp .)
    GET             reduce using rule 15 (exp -> exp DIVIDE exp .)
    PUT             reduce using rule 15 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 15 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 15 (exp -> exp DIVIDE exp .)
    {               reduce using rule 15 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 15 (exp -> exp DIVIDE exp .)
    }               reduce using rule 15 (exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 15 (exp -> exp DIVIDE exp .)
    )               reduce using rule 15 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 28 ]
  ! MINUS           [ shift and go to state 29 ]
  ! TIMES           [ shift and go to state 30 ]
  ! DIVIDE          [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 45

    (16) exp -> exp EQ exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    EQ              reduce using rule 16 (exp -> exp EQ exp .)
    LE              reduce using rule 16 (exp -> exp EQ exp .)
    ;               reduce using rule 16 (exp -> exp EQ exp .)
    ID              reduce using rule 16 (exp -> exp EQ exp .)
    GET             reduce using rule 16 (exp -> exp EQ exp .)
    PUT             reduce using rule 16 (exp -> exp EQ exp .)
    WHILE           reduce using rule 16 (exp -> exp EQ exp .)
    IF              reduce using rule 16 (exp -> exp EQ exp .)
    {               reduce using rule 16 (exp -> exp EQ exp .)
    $end            reduce using rule 16 (exp -> exp EQ exp .)
    }               reduce using rule 16 (exp -> exp EQ exp .)
    ELSE            reduce using rule 16 (exp -> exp EQ exp .)
    )               reduce using rule 16 (exp -> exp EQ exp .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31

  ! PLUS            [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! MINUS           [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! TIMES           [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! DIVIDE          [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 46

    (17) exp -> exp LE exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    EQ              reduce using rule 17 (exp -> exp LE exp .)
    LE              reduce using rule 17 (exp -> exp LE exp .)
    ;               reduce using rule 17 (exp -> exp LE exp .)
    ID              reduce using rule 17 (exp -> exp LE exp .)
    GET             reduce using rule 17 (exp -> exp LE exp .)
    PUT             reduce using rule 17 (exp -> exp LE exp .)
    WHILE           reduce using rule 17 (exp -> exp LE exp .)
    IF              reduce using rule 17 (exp -> exp LE exp .)
    {               reduce using rule 17 (exp -> exp LE exp .)
    $end            reduce using rule 17 (exp -> exp LE exp .)
    }               reduce using rule 17 (exp -> exp LE exp .)
    ELSE            reduce using rule 17 (exp -> exp LE exp .)
    )               reduce using rule 17 (exp -> exp LE exp .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31

  ! PLUS            [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! EQ              [ shift and go to state 32 ]
  ! LE              [ shift and go to state 33 ]


state 47

    (20) exp -> ( exp ) .

    PLUS            reduce using rule 20 (exp -> ( exp ) .)
    MINUS           reduce using rule 20 (exp -> ( exp ) .)
    TIMES           reduce using rule 20 (exp -> ( exp ) .)
    DIVIDE          reduce using rule 20 (exp -> ( exp ) .)
    EQ              reduce using rule 20 (exp -> ( exp ) .)
    LE              reduce using rule 20 (exp -> ( exp ) .)
    ;               reduce using rule 20 (exp -> ( exp ) .)
    ID              reduce using rule 20 (exp -> ( exp ) .)
    GET             reduce using rule 20 (exp -> ( exp ) .)
    PUT             reduce using rule 20 (exp -> ( exp ) .)
    WHILE           reduce using rule 20 (exp -> ( exp ) .)
    IF              reduce using rule 20 (exp -> ( exp ) .)
    {               reduce using rule 20 (exp -> ( exp ) .)
    $end            reduce using rule 20 (exp -> ( exp ) .)
    }               reduce using rule 20 (exp -> ( exp ) .)
    ELSE            reduce using rule 20 (exp -> ( exp ) .)
    )               reduce using rule 20 (exp -> ( exp ) .)


state 48

    (7) stmt -> WHILE ( exp ) . stmt
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10

    stmt                           shift and go to state 50

state 49

    (8) stmt -> IF ( exp ) . stmt opt_else
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10

    stmt                           shift and go to state 51

state 50

    (7) stmt -> WHILE ( exp ) stmt .

    ID              reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    GET             reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    PUT             reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    WHILE           reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    IF              reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    {               reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    $end            reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    }               reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    ELSE            reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)


state 51

    (8) stmt -> IF ( exp ) stmt . opt_else
    (10) opt_else -> . ELSE stmt
    (11) opt_else -> . empty
    (25) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 53
    ID              reduce using rule 25 (empty -> .)
    GET             reduce using rule 25 (empty -> .)
    PUT             reduce using rule 25 (empty -> .)
    WHILE           reduce using rule 25 (empty -> .)
    IF              reduce using rule 25 (empty -> .)
    {               reduce using rule 25 (empty -> .)
    $end            reduce using rule 25 (empty -> .)
    }               reduce using rule 25 (empty -> .)

  ! ELSE            [ reduce using rule 25 (empty -> .) ]

    opt_else                       shift and go to state 52
    empty                          shift and go to state 54

state 52

    (8) stmt -> IF ( exp ) stmt opt_else .

    ID              reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    GET             reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    PUT             reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    WHILE           reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    IF              reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    {               reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    $end            reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    }               reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    ELSE            reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)


state 53

    (10) opt_else -> ELSE . stmt
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10

    stmt                           shift and go to state 55

state 54

    (11) opt_else -> empty .

    ID              reduce using rule 11 (opt_else -> empty .)
    GET             reduce using rule 11 (opt_else -> empty .)
    PUT             reduce using rule 11 (opt_else -> empty .)
    WHILE           reduce using rule 11 (opt_else -> empty .)
    IF              reduce using rule 11 (opt_else -> empty .)
    {               reduce using rule 11 (opt_else -> empty .)
    $end            reduce using rule 11 (opt_else -> empty .)
    }               reduce using rule 11 (opt_else -> empty .)
    ELSE            reduce using rule 11 (opt_else -> empty .)


state 55

    (10) opt_else -> ELSE stmt .

    ID              reduce using rule 10 (opt_else -> ELSE stmt .)
    GET             reduce using rule 10 (opt_else -> ELSE stmt .)
    PUT             reduce using rule 10 (opt_else -> ELSE stmt .)
    WHILE           reduce using rule 10 (opt_else -> ELSE stmt .)
    IF              reduce using rule 10 (opt_else -> ELSE stmt .)
    {               reduce using rule 10 (opt_else -> ELSE stmt .)
    $end            reduce using rule 10 (opt_else -> ELSE stmt .)
    }               reduce using rule 10 (opt_else -> ELSE stmt .)
    ELSE            reduce using rule 10 (opt_else -> ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 51 resolved as shift
